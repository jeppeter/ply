#! /usr/bin/env python

import sys
import os
import importlib
import extargsparse
import logging

def _insert_path(path,*args):
    _curdir = os.path.join(path,*args)
    if _curdir  in sys.path:
        sys.path.remove(_curdir)
    sys.path.insert(0,_curdir)
    return

_insert_path(os.path.dirname(os.path.realpath(__file__)))
_insert_path(os.path.dirname(os.path.realpath(__file__)),'..','..')

import ply.yacc as yacc
import testlex as dlex
import dhcpconf

class ConfigDhcpYacc(object):pass

class DhcpConfYacc(ConfigDhcpYacc):
    tokens = dlex.DhcpConfLex.tokens
    def __init__(self,lexer=None):
    	super(DhcpConfYacc,self).__init__()
        self.lexer = lexer
        self.statements = None
        return

    def format_config(self):
        s = ''
        if self.statements is not None:
            #logging.info('statements %s'%(repr(self.statements)))
            s += self.statements.format_config()
        return s

    def p_statements_empty(self,p):
        ''' statements : empty
        '''
        p[0] = dhcpconf.Statements(None,None,p[1],p[1])
        p[1] = None
        if self.statements is not None:
            self.statements = None
        self.statements = p[0]
        return

    def p_statements_statement(self,p):
        '''statements : statements statement
        '''
        p[1].append_child(p[2])
        p[1].set_pos_by_children()
        p[0] = p[1]
        p[1] = None
        if self.statements is not None:
            self.statements = None
        self.statements = p[0]
        return

    def p_statement_multi(self,p):
        ''' statement :  option_statement
        '''
        children = []
        children.append(p[1])
        p[0] = dhcpconf.Statement(None,children,p[1],p[1])
        p[1] = None
        return

    def p_empty(self,p):
        ''' empty :     
        '''
        startpos = dhcpconf.Location(p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos),p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos))
        p[0] = dhcpconf.YaccDhcpObject('Empty',None,startpos,startpos)
        return

   	def p_error(self,p):
   		raise Exception('get error %s'%(repr(p)))

    def build(self,**kwargs):
        return yacc.yacc(module=self,start='statements',**kwargs)


def read_file(infile=None):
    fin = sys.stdin
    if infile is not None:
        logging.info('infile %s'%(infile))
        fin = open(infile,'r')
    bmode = False
    if 'b' in fin.mode:
        bmode = True
    s = ''
    for l in fin:
        if sys.version[0] == '2' or not bmode:
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    return s

def set_logging(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return


def main():
    command='''
    {
        "verbose|v" : "+",
        "input|i" : null
    }
    '''
    parser = extargsparse.ExtArgsParse()
    parser.load_command_line_string(command)
    args = parser.parse_command_line()
    set_logging(args)
    s = read_file(args.input)
    dhcplex = dlex.DhcpConfLex()
    lexer = dhcplex.build()
    dhcpyacc = DhcpConfYacc(lexer)
    parser = dhcpyacc.build(tabmodule='testparse')
    parser.parse(s)
    s = dhcpyacc.format_config()
    sys.stdout.write('%s'%(s))
    return

if __name__ == '__main__':
    main()

