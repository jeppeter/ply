#! /usr/bin/env python

import sys
import os
import importlib
import extargsparse
import logging

def _insert_path(path,*args):
    _curdir = os.path.join(path,*args)
    if _curdir  in sys.path:
        sys.path.remove(_curdir)
    sys.path.insert(0,_curdir)
    return

_insert_path(os.path.dirname(os.path.realpath(__file__)))
_insert_path(os.path.dirname(os.path.realpath(__file__)),'..','..')

import ply.yacc as yacc
import ply.lex as lex
import testlex as dlex
import dhcpconf

class ConfigDhcpYacc(object):pass

class DhcpConfYacc(ConfigDhcpYacc):
    tokens = dlex.DhcpConfLex.tokens
    def __init__(self,lexer=None):
        super(DhcpConfYacc,self).__init__(lexer)
        return

    def format_config(self):
        s = ''
        if self.statements is not None:
            #logging.info('statements %s'%(repr(self.statements)))
            s += self.statements.format_config()
        return s

    def p_option_statement_1(self,p):
        ''' option_statement : option_default_lease_time
               | option_ddns_update_style
               | option_filename
               | option_next_server
               | option_domain_name
               | option_domain_name_servers
               | option_log_servers
               | option_log_facility
               | option_max_lease_time
        '''
        p[0] = p[1]
        p[1] = None
        return

    def p_data_expr_op_0(self,p):
        ''' data_expr_op : NUMBER
          | TEXT
        '''
        p[0] = dhcpconf.ExprOp()
        constdata = dhcpconf.ConstData(p.slice[1].value,p.slice[1],p.slice[1])
        p[0].append_child_and_set_pos(constdata)
        constdata = None
        return

    def p_data_expr_op_1(self,p):
        ''' data_expr_op : hardware_addr
        '''
        p[0] = dhcpconf.ExprOp()
        p[0].append_child_and_set_pos(p[1])
        p[1] = None
        return


    def p_uid_data_0(self,p):
        ''' uid_data : ipv6_addr
        '''
        p[0] = dhcpconf.UidData(None,None,p[1],p[1])
        p[0].set_value(p[1].value_format())
        return

    def p_host_name_0(self,p):
        ''' host_name : TEXT
                | NUMBER
        '''
        p[0] =dhcpconf.HostName(None,p.slice[1],p.slice[1])
        p[0].start_hostname(p.slice[1].value)
        return

    def p_hardware_type_0(self,p):
        ''' hardware_type : ETHERNET
                   | TOKEN_RING
                   | FDDI
                   | INFINIBAND
        '''
        p[0] = dhcpconf.HardwareType(p.slice[1].value,p.slice[1],p.slice[1])
        return

    def p_hardware_addr_0(self,p):
        ''' hardware_addr : NUMBER
                  | TEXT
                  | hardware_addr COLON NUMBER
                  | hardware_addr COLON TEXT
        '''
        if len(p) == 2:
            logging.info('hardware_addr init %s'%(p.slice[1].value))
            p[0] = dhcpconf.HardwareAddr(None,None,p.slice[1],p.slice[1])
            p[0].start_addr(p.slice[1].value)
        else:
            p[0] = p[1]
            p[0].append_colone_text(p.slice[3].value)
            p[0].set_endpos(p.slice[3])
            p[1] = None
        return

    def p_host_identifier_declaration_0(self,p):
        ''' host_identifier_declaration : HOST_IDENTIFIER OPTION option_name option_value_part SEMI
        '''
        logging.info('can get host_identifier_declaration')
        p[0] = dhcpconf.OptionHandle(None,p.slice[1],p.slice[5]).handle_option(p[3],p.slice[1],p.slice[5],p[4])
        return

    def p_option_value_part_0(self,p):
        ''' option_value_part : EQUAL data_expr_op
                 | arg_space_list
        '''
        if len(p) == 3:
            p[0] = dhcpconf.OptionValue(None,None,p.slice[1],p[2])
            constdata = dhcpconf.ConstData(p.slice[1],p.slice[1],p.slice[1])
            p[0].append_child(constdata)
            p[0].append_child(p[2])
            p[2] = None
        else:
            p[0] = dhcpconf.OptionValue(None,None,p[1],p[1])
            p[0].append_child(p[1])
            p[1] = None
        return

    def p_arg_space_list(self,p):
        ''' arg_space_list : empty
                    | arg_space_list data_expr_op
        '''
        if len(p) == 2:
            p[0] = dhcpconf.ArgSpaceList(None,None,p[1],p[1])
        elif len(p) == 3:
            p[0] = p[1].append_child_and_set_pos(p[2])
            p[1] = None
        return


    def p_host_name_1(self,p):
        ''' host_name : host_name DOT TEXT
                | host_name DOT NUMBER
        '''
        p[0] = p[1]
        p[0].append_dot_text(p.slice[3].value,p.slice[3])
        p[1] = None
        return

    def p_host_name_3(self,p):
        ''' host_name : host_name COLON TEXT
              | host_name COLON NUMBER
        '''
        p[0] = p[1]
        p[0].append_colone_text(p.slice[3].value,p.slice[3])
        return

    def p_option_name_0(self,p):
        ''' option_name : special_identifier
               | special_identifier DOT special_identifier
        '''
        if len(p) == 2:
            p[0] = dhcpconf.OptionName(p[1].value_format(),p[1],p[1])
            p[1] = None
        else:
            value = '%s.%s'%(p[1].value_format(),p[3].value_format())
            p[0] = dhcpconf.OptionName(value,p[1],p[3])
            p[1] = None
            p[3] = None
        return

    def p_error(self,p):
        if isinstance(p,object) and isinstance(p,lex.LexToken):
            pass
        raise Exception('error handle %s'%(repr(p)))

    def build(self,**kwargs):
        return yacc.yacc(module=self,start='statements',**kwargs)


def read_file(infile=None):
    fin = sys.stdin
    if infile is not None:
        logging.info('infile %s'%(infile))
        fin = open(infile,'r')
    bmode = False
    if 'b' in fin.mode:
        bmode = True
    s = ''
    for l in fin:
        if sys.version[0] == '2' or not bmode:
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    return s

def set_logging(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return


def main():
    command='''
    {
        "verbose|v" : "+",
        "input|i" : null
    }
    '''
    parser = extargsparse.ExtArgsParse()
    parser.load_command_line_string(command)
    args = parser.parse_command_line()
    set_logging(args)
    if args.verbose >= 3:
        yacc.yaccdevel = True
    s = read_file(args.input)
    dhcplex = dlex.DhcpConfLex()
    lexer = dhcplex.build()
    dhcpyacc = DhcpConfYacc(lexer)
    parser = dhcpyacc.build(tabmodule='testparse')
    parser.parse(s)
    s = dhcpyacc.format_config()
    sys.stdout.write('%s'%(s))
    return

if __name__ == '__main__':
    main()

