#! /usr/bin/env python

import sys
import os
import importlib
import extargsparse
import logging
import re
import types

def _insert_path(path,*args):
    _curdir = os.path.join(path,*args)
    if _curdir  in sys.path:
        sys.path.remove(_curdir)
    sys.path.insert(0,_curdir)
    return

_insert_path(os.path.dirname(os.path.realpath(__file__)),'..','..')
_insert_path(os.path.dirname(os.path.realpath(__file__)))
import ply.yacc as yacc
import tgtlex as tgtlex
from cmnfile import read_file,set_logging
import tgtconf
import location


class TgtConfigYacc(object):pass


class TgtYacc(TgtConfigYacc):
    tokens = tgtlex.TgtLex.tokens
    def __init__(self,lexer=None):
        super(TgtYacc,self).__init__(lexer)
        self.statements = None
        return

    def set_statements(self,p):
        self.statements = p
        return

    def p_statements_0(self,p):
        ''' statements : empty
                  | statements statement
        '''
        if len(p) == 2:
            p[0] = tgtconf.Statements(None,None,p[1],p[1])
            p[1] = None
        elif len(p) == 3:
            logging.info('p[2] filename %s'%(p[2].filename))
            p[0] = p[1].append_child_and_set_pos(p[2])
            p[1] = None
            p[2] = None
        self.set_statements(p[0])
        return

    def p_statement_0(self,p):
        ''' statement : include_statement
                | target_statement
        '''
        p[0] = p[1]
        p[1] = None
        return

    def p_include_statement_0(self,p):
        ''' include_statement : INCLUDE path
        '''
        p[0] = tgtconf.IncludeStatement(p[2].get_path(),p.slice[1],p[2])
        if self.lexer is not None:
            # we include the 
            logging.info('include for %s self.lexer %s'%(repr(p.lexer),repr(self.lexer)))
            s = read_file(p[2].get_path())
            self.lexer.input(s,p[2].get_path())
        p[2] = None
        return

    def p_target_statement_0(self,p):
        ''' target_statement : target_prefix target_declarations target_suffix
        '''
        p[0] = tgtconf.TargetStatement(None,None,p[1],p[3])
        p[0].set_name(p[1])
        p[0].append_child(p[2])
        p[1] = None
        p[2] = None
        p[3] = None
        logging.info('get target %s'%(repr(p[0])))
        return

    def p_target_prefix_0(self,p):
        ''' target_prefix : LBRACKET TARGET iqn_name RBRACKET
        '''
        p[0] = p[3]
        p[0].set_startpos(p.slice[1])
        p[0].set_endpos(p.slice[4])
        p[3] = None
        return

    def p_iqn_name_0(self,p):
        ''' iqn_name : TEXT
             | NUMBER
        '''
        p[0] = tgtconf.IQNName(None,None,p.slice[1],p.slice[1])
        p[0].start_name(p.slice[1].value)
        return

    def p_iqn_name_1(self,p):
        ''' iqn_name : iqn_name DOT TEXT
                 | iqn_name DOT NUMBER
                 | iqn_name COLON TEXT
                 | iqn_name COLON NUMBER
        '''
        p[0] = p[1]
        p[0].append_name(p.slice[2].value,p.slice[3].value)
        p[1] = None
        return

    def p_target_suffix_0(self,p):
        ''' target_suffix : LBRACKET SLASH TARGET RBRACKET
        '''
        p[0] = tgtconf.TargetSuffix(None,None,p.slice[1],p.slice[4])
        return

    def p_target_declarations_0(self,p):
        ''' target_declarations : empty
                  | target_declarations target_declaration
        '''
        if len(p) == 2:
            p[0] = tgtconf.TargetDeclarations(None,None,p[1],p[1])
            p[1] = None
        elif len(p) == 3:
            p[0] = p[1].append_child_and_set_pos(p[2])
            p[1] = None
            p[2] = None
        return

    def p_target_declaration_0(self,p):
        ''' target_declaration : backing_store_declaration
                  | direct_store_declaration
        '''
        p[0] = p[1]
        p[1] = None
        return

    def p_backing_store_declaration_0(self,p):
        ''' backing_store_declaration : BACKING_STORE path
                   | BACKING_STORE
        '''
        if len(p) == 3:
            logging.info('get 3 backing_store_declaration')
            p[0] = tgtconf.BackingStoreDeclaration(None,None,p.slice[1],p[2])
            p[0].append_child(p[2])
            p[2] = None
        elif len(p) == 2:
            p[0] = tgtconf.BackingStoreDeclaration(None,None,p.slice[1],p.slice[1])
        return

    def p_path_0(self,p):
        ''' path : NUMBER
                | TEXT
                | SLASH
        '''
        p[0] = tgtconf.Path(None,None,p.slice[1],p.slice[1])
        p[0].start_path(p.slice[1].value)
        return

    def p_path_1(self,p):
        ''' path : path SLASH
                | path NUMBER
                | path TEXT
        '''
        p[0] = p[1]
        p[0].set_endpos(p.slice[2])
        p[0].append_path(p.slice[2].value)
        p[1] = None
        return

    def p_direct_store_declaration_0(self,p):
        ''' direct_store_declaration : DIRECT_STORE path
        '''
        p[0] = tgtconf.DirectStoreDeclaration(None,None,p.slice[1],p[2])
        p[0].append_child(p[2])
        p[2] = None
        return

    def p_empty_0(self,p):
        ''' empty :
        '''
        startpos = location.Location(p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos),p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos))
        p[0] = tgtconf.YaccDhcpObject('Empty',None,startpos,startpos)
        return

    def format_config(self,tabs=0):
        s = ''
        if self.statements is not None:
            s = self.statements.format_config(tabs)
        return s

    def p_error(self,p):
        raise Exception('can not parse %s'%(repr(p)))

    def build(self,**kwargs):
        return yacc.yacc(module=self,start='statements',**kwargs)

class Idx(object):
    def __init__(self):
        self.idx = 0
        return

def get_token_func(tokens):
    scope = Idx()
    def token_func():
        rettok = None
        if scope.idx < len(tokens):
            rettok = tokens[scope.idx]
        logging.info('[%d] %s'%(scope.idx,repr(rettok)))
        scope.idx += 1
        return rettok
    return token_func


def config_handler(args,parser):
    set_logging(args)
    tlex = tgtlex.TgtLex()
    s = read_file(args.input)
    fname = '<stdin>'
    if args.input is not None:
        fname = args.input
    alltokens,lexer = tlex.build_tokens(s,fname,lextab='tgtlex')
    for c in alltokens:
        logging.info('%s'%(repr(c)))
    tyacc = TgtYacc(lexer)
    parser = tyacc.build(tabmodule='tgtparse')
    if args.verbose >= 3:
        yacc.yaccdevel = True
    logging.info('lexer %s'%(repr(lexer)))
    parser.parse(input=None,lexer=lexer,debug=3,tokenfunc=get_token_func(alltokens))
    s = tyacc.format_config(0)
    sys.stdout.write('%s'%(s))
    sys.exit(0)
    return

def main():
    command='''
    {
        "verbose|v" : "+",
        "input|i" : null,
        "config<config_handler>" : {
            "$" : 0
        }
    }
    '''
    parser = extargsparse.ExtArgsParse()
    parser.load_command_line_string(command)
    args = parser.parse_command_line()
    return

if __name__ == '__main__':
    main()

