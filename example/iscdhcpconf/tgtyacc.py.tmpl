#! /usr/bin/env python

import sys
import os
import importlib
import extargsparse
import logging
import re
import types

def _insert_path(path,*args):
    _curdir = os.path.join(path,*args)
    if _curdir  in sys.path:
        sys.path.remove(_curdir)
    sys.path.insert(0,_curdir)
    return

_insert_path(os.path.dirname(os.path.realpath(__file__)),'..','..')
_insert_path(os.path.dirname(os.path.realpath(__file__)))
import ply.yacc as yacc
import tgtlex as tgtlex
from cmnfile import read_file,set_logging,expand_files
import tgtconf
import location


class TgtConfigYacc(object):pass


class TgtYacc(TgtConfigYacc):
    tokens = tgtlex.TgtLex.tokens
    def __init__(self,lexer=None):
        super(TgtYacc,self).__init__(lexer)
        self.statements = None
        return

    def set_statements(self,p):
        self.statements = p
        return

    def p_statements_0(self,p):
        ''' statements : empty
                  | statements statement
        '''
        if len(p) == 2:
            p[0] = tgtconf.Statements(None,None,p[1],p[1])
            p[1] = None
        elif len(p) == 3:
            logging.info('p[2] filename %s'%(p[2].filename))
            p[0] = p[1].append_child_and_set_pos(p[2])
            p[1] = None
            p[2] = None
        self.set_statements(p[0])
        return

    def p_statement_0(self,p):
        ''' statement : include_statement
                | target_statement
        '''
        p[0] = p[1]
        p[1] = None
        return


    def p_target_declaration_0(self,p):
        ''' target_declaration : backing_store_declaration
                  | direct_store_declaration
                  | driver_declaration
                  | initiator_address_declaration
                  | initiator_name_declaration
                  | incominguser_declaration
                  | outgoinguser_declaration
                  | controller_tid_declaration
        '''
        p[0] = p[1]
        p[1] = None
        return

    def format_config(self,tabs=0):
        s = ''
        if self.statements is not None:
            s = self.statements.format_config(tabs)
        return s

    def p_error(self,p):
        raise Exception('can not parse %s'%(repr(p)))

    def build(self,**kwargs):
        return yacc.yacc(module=self,start='statements',**kwargs)

class Idx(object):
    def __init__(self):
        self.idx = 0
        return

def get_token_func(tokens):
    scope = Idx()
    def token_func():
        rettok = None
        if scope.idx < len(tokens):
            rettok = tokens[scope.idx]
        logging.info('[%d] %s'%(scope.idx,repr(rettok)))
        scope.idx += 1
        return rettok
    return token_func


def config_handler(args,parser):
    set_logging(args)
    tlex = tgtlex.TgtLex()
    s = read_file(args.input)
    fname = '<stdin>'
    if args.input is not None:
        fname = args.input
    alltokens,lexer = tlex.build_tokens(s,fname,lextab='tgtlex')
    for c in alltokens:
        logging.info('%s'%(repr(c)))
    tyacc = TgtYacc(lexer)
    parser = tyacc.build(tabmodule='tgtparse')
    if args.verbose >= 3:
        yacc.yaccdevel = True
    logging.info('lexer %s'%(repr(lexer)))
    parser.parse(input=None,lexer=lexer,debug=3,tokenfunc=get_token_func(alltokens))
    s = tyacc.format_config(0)
    sys.stdout.write('%s'%(s))
    sys.exit(0)
    return

def main():
    command='''
    {
        "verbose|v" : "+",
        "input|i" : null,
        "config<config_handler>" : {
            "$" : 0
        }
    }
    '''
    parser = extargsparse.ExtArgsParse()
    parser.load_command_line_string(command)
    args = parser.parse_command_line()
    return

if __name__ == '__main__':
    main()

