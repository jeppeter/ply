{
    "backing_store_declaration": {
        "prefix": "backing_store_declaration",
        "yacc": [
            {
                "clause": " BACKING_STORE path; BACKING_STORE;",
                "func": "if len(p) == 3:;{logging.info('get 3 backing_store_declaration');p[0] = tgtconf.BackingStoreDeclaration(None,None,p.slice[1],p[2]);p[0].append_child(p[2]);p[2] = None;}elif len(p) == 2:;{p[0] = tgtconf.BackingStoreDeclaration(None,None,p.slice[1],p.slice[1]);}return;"
            }
        ]
    },
    "direct_store_declaration": {
        "prefix": "direct_store_declaration",
        "yacc": [
            {
                "clause": " DIRECT_STORE path;",
                "func": "p[0] = tgtconf.DirectStoreDeclaration(None,None,p.slice[1],p[2]);p[0].append_child(p[2]);p[2] = None;return;"
            }
        ]
    },
    "driver_declaration": {
        "prefix": "driver_declaration",
        "yacc": [
            {
                "clause": " DRIVER lld_name;",
                "func": "p[0] = tgtconf.DriverDeclaration(None,None,p.slice[1],p[2]);p[0].append_child(p[2]);p[2] = None;return;"
            }
        ]
    },
    "empty": {
        "prefix": "empty",
        "yacc": [
            {
                "clause": ";",
                "func": "startpos = location.Location(p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos),p.lexer.lineno,(p.lexer.lexpos-p.lexer.linepos));p[0] = tgtconf.YaccDhcpObject('Empty',None,startpos,startpos);return;"
            }
        ]
    },
    "include_statement": {
        "prefix": "include_statement",
        "yacc": [
            {
                "clause": " INCLUDE path;",
                "func": "p[0] = tgtconf.IncludeStatement(p[2].get_path(),p.slice[1],p[2]);p[2] = None;return;"
            }
        ]
    },
    "iqn_name": {
        "prefix": "iqn_name",
        "yacc": [
            {
                "clause": " TEXT; NUMBER;",
                "func": "p[0] = tgtconf.IQNName(None,None,p.slice[1],p.slice[1]);p[0].start_name(p.slice[1].value);return;"
            },
            {
                "clause": " iqn_name DOT TEXT; iqn_name DOT NUMBER; iqn_name COLON TEXT; iqn_name COLON NUMBER;",
                "func": "p[0] = p[1];p[0].append_name(p.slice[2].value,p.slice[3].value);p[1] = None;return;"
            }
        ]
    },
    "lld_name": {
        "prefix": "lld_name",
        "yacc": [
            {
                "clause": " ISCSI; ISER;",
                "func": "p[0] = tgtconf.LLDName(p.slice[1].value,p.slice[1],p.slice[1]);return;"
            }
        ]
    },
    "path": {
        "prefix": "path",
        "yacc": [
            {
                "clause": " NUMBER; TEXT; SLASH; STAR; DOT;",
                "func": "p[0] = tgtconf.Path(None,None,p.slice[1],p.slice[1]);p[0].start_path(p.slice[1].value);return;"
            },
            {
                "clause": " path SLASH; path NUMBER; path TEXT; path STAR; path DOT;",
                "func": "p[0] = p[1];p[0].set_endpos(p.slice[2]);p[0].append_path(p.slice[2].value);p[1] = None;return;"
            }
        ]
    },
    "target_declarations": {
        "prefix": "target_declarations",
        "yacc": [
            {
                "clause": " empty; target_declarations target_declaration;",
                "func": "if len(p) == 2:;{p[0] = tgtconf.TargetDeclarations(None,None,p[1],p[1]);p[1] = None;}elif len(p) == 3:;{p[0] = p[1].append_child_and_set_pos(p[2]);p[1] = None;p[2] = None;}return;"
            }
        ]
    },
    "target_prefix": {
        "prefix": "target_prefix",
        "yacc": [
            {
                "clause": " LBRACKET TARGET iqn_name RBRACKET;",
                "func": "p[0] = p[3];p[0].set_startpos(p.slice[1]);p[0].set_endpos(p.slice[4]);p[3] = None;return;"
            }
        ]
    },
    "target_statement": {
        "prefix": "target_statement",
        "yacc": [
            {
                "clause": " target_prefix target_declarations target_suffix;",
                "func": "p[0] = tgtconf.TargetStatement(None,None,p[1],p[3]);p[0].set_name(p[1]);p[0].append_child(p[2]);p[1] = None;p[2] = None;p[3] = None;logging.info('get target %s'%(repr(p[0])));return;"
            }
        ]
    },
    "target_suffix": {
        "prefix": "target_suffix",
        "yacc": [
            {
                "clause": " LBRACKET SLASH TARGET RBRACKET;",
                "func": "p[0] = tgtconf.TargetSuffix(None,None,p.slice[1],p.slice[4]);return;"
            }
        ]
    },
    "initiator_address_declaration": {
        "prefix": "initiator_address_declaration",
        "yacc": [
            {
                "clause": " INITIATOR_ADDRESS ipaddr;",
                "func": "p[0] = tgtconf.InitiatorAddress(None,None,p.slice[1],p[2]);p[0].append_child(p[2]);p[2] = None;return;"
            }
        ]
    },
    "ipaddr": {
        "prefix": "ipaddr",
        "yacc": [
            {
                "clause": " ipv4_addr; ipv6_addr;",
                "func": "p[0] = p[1];p[1] = None;return;"
            }
        ]
    },
    "ipv4_addr": {
        "prefix": "ipv4_addr",
        "yacc": [
            {
                "clause": " NUMBER DOT NUMBER DOT NUMBER DOT NUMBER;",
                "func": "p[0] = tgtconf.Ipv4Addr(None,None,p.slice[1],p.slice[7]);p[0].start_addr(p.slice[1].value);idx = 3;while idx < 8:;{p[0].add_dot_text(p.slice[idx].value);idx += 2;}return;"
            }
        ]
    },
    "ipv6_addr": {
        "prefix": "ipv6_addr",
        "yacc": [
            {
                "clause": " NUMBER; TEXT;",
                "func": "p[0] = tgtconf.Ipv6Addr(None,None,p.slice[1],p.slice[1]);p[0].start_addr(p.slice[1].value);return;"
            },
            {
                "clause": " ipv6_addr COLON;",
                "func": "p[0] = p[1];p[0].add_colon();p[0].set_endpos(p.slice[2]);p[1] = None;return;"
            },
            {
                "clause": " ipv6_addr COLON TEXT; ipv6_addr COLON NUMBER;",
                "func": "p[0] = p[1];p[0].add_colon_text(p.slice[3].value);p[0].set_endpos(p.slice[3]);p[1] = None;return;"
            }
        ]
    },
    "include" : "INCLUDE",
    "target" : "TARGET",
    "direct-store" : "DIRECT_STORE",
    "backing-store" : "BACKING_STORE",
    "iscsi" : "ISCSI",
    "iser" : "ISER" ,
    "driver" : "DRIVER",
    "initiator-address" : "INITIATOR_ADDRESS"
}