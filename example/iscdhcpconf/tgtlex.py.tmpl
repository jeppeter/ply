#! /usr/bin/env python

import sys
import os
import importlib
import extargsparse
import logging
import re
import types

def _insert_path(path,*args):
	_curdir = os.path.join(path,*args)
	if _curdir  in sys.path:
		sys.path.remove(_curdir)
	sys.path.insert(0,_curdir)
	return

_insert_path(os.path.dirname(os.path.realpath(__file__)),'..','..')
_insert_path(os.path.dirname(os.path.realpath(__file__)))
import ply.lex as lex
from cmnfile import set_logging,read_file

def tgtlex_input(self,s,filename='<string>'):
	if getattr(self,'linepos',None) is not None:
		#logging.info('push [%s:%s:%s]'%(self.filename,
		#		self.lineno,(self.lexpos - self.linepos)))
		self.oldlexpos.append(self.lexpos)
		self.oldlexdata.append(self.lexdata)
		self.oldlineno.append(self.lineno)
		self.oldlinepos.append(self.linepos)
		self.oldfilename.append(self.filename)
		self.oldlexlen.append(self.lexlen)
	else:
		self.oldlexpos = []
		self.oldlexdata = []
		self.oldlineno = []
		self.oldlinepos = []
		self.oldfilename = []
		self.oldlexlen = []
	self.linepos = 0
	self.lexpos = 0
	self.lexdata = s
	self.lineno = 1
	self.lexlen = len(s)
	self.filename = filename
	#logging.info('set [%s:%s]'%(self.filename,self.lexdata))
	return
	

def tgtlex_token(self):
	retval = None
	while retval is None:
		if self.lexpos >= len(self.lexdata) :
			# ok we should search
			if getattr(self,'oldlexpos',None) is not None and \
				 len(self.oldlexpos) > 0:
				self.lexpos = self.oldlexpos.pop()
				self.lexdata = self.oldlexdata.pop()
				self.lineno = self.oldlineno.pop()
				self.linepos = self.oldlinepos.pop()
				self.filename = self.oldfilename.pop()
				self.lexlen = self.oldlexlen.pop()
				#logging.info('restore [%s:%s:%s]'%(self.filename,self.lineno,(self.lexpos - self.linepos)))
			else:
				# nothing to handle
				break
		retval = self.orig_token()
	return retval

class TgtConfigLex(object):pass

class TgtLex(TgtConfigLex):
	tokens = ['COMMENT','TEXT','LBRACKET','RBRACKET','DQUOTE','SLASH']
	t_ignore = ' \t'
	t_dquote_ignore = ''
	t_comment_ignore = ''
	states = (
		('dquote','exclusive'),
		('comment','exclusive'),
	)
	def __init__(self):
		super(TgtLex,self).__init__()
		self.__class__.tokens += list(self.__class__.reserved.values())
		self.lineno = 1
		self.column = 0
		return

	@lex.TOKEN(r'\<')
	def t_LBRACKET(self,p):
		p.startline = p.lexer.lineno
		p.startpos = p.lexer.lexpos - len(p.value)
		p.endline = p.startline
		p.endpos = p.lexer.lexpos
		p.filename = p.lexer.filename
		return p

	@lex.TOKEN(r'\/')
	def t_SLASH(self,p):
		p.startline = p.lexer.lineno
		p.startpos = p.lexer.lexpos - len(p.value)
		p.endline = p.startline
		p.endpos = p.lexer.lexpos
		p.filename = p.lexer.filename
		return p

	@lex.TOKEN(r'\>')
	def t_RBRACKET(self,p):
		p.startline = p.lexer.lineno
		p.startpos = p.lexer.lexpos - len(p.value)
		p.endline = p.startline
		p.endpos = p.lexer.lexpos
		p.filename = p.lexer.filename
		return p

	@lex.TOKEN(r'"')
	def t_DQUOTE(self,p):
		p.lexer.push_state('dquote')
		return None

	@lex.TOKEN('.')
	def t_comment_TEXT(self,p):
		curpos = p.lexer.lexpos
		maxpos = len(p.lexer.lexdata)
		while curpos < maxpos:
			curch = p.lexer.lexdata[curpos]
			if curch == '\n':
				curpos += 1
				p.lexer.lineno += 1
				p.lexer.linepos = curpos
				break
			curpos += 1
		self.comment = 0
		p.lexer.pop_state()
		p.lexer.lexpos = curpos
		return None

	def t_comment_error(self,p):
		raise Exception('can not make comment for (%s)'%(repr(p)))

	@lex.TOKEN(r'.')
	def t_dquote_TEXT(self,p):
		s = ''
		slashed = False
		if p.value == '"':
			p.startline = p.lexer.lineno
			p.startpos = (p.lexer.lexpos - p.lexer.linepos - len(p.value))
			p.endpos = p.startpos + len(p.value)
			p.endline = p.startline
			p.value = s
			return p
		elif p.value != '\\':
			s += p.value
		else:
			slashed = True
		quoted = True
		startpos = (p.lexer.lexpos - p.lexer.linepos - len(p.value))
		startline = p.lexer.lineno
		curpos = p.lexer.lexpos
		while curpos < len(p.lexer.lexdata):
			curch = p.lexer.lexdata[curpos]
			if slashed :
				if curch == 'n' :
					s += '\n'
				elif curch == 't':
					s += '\t'
				elif curch == 'b':
					if len(s) > 1:
						s = s[:-2]
					else:
						raise Exception('can not accept one length')
				else:
					s += curch
				slashed = False
			elif curch == '"':
				quoted = False
				curpos += 1
				break
			elif curch == '\\':
				slashed = True
			elif curch == '\n':
				p.lexer.lineno += 1
				p.lexer.linepos = curpos
				s += curch
			else:
				s += curch
			curpos += 1
		if quoted or slashed:
			raise Exception('not closed string %s'%(p.lexer.lexdata[startpos:]))
		p.startline = startline
		p.startpos = startpos
		p.endline = p.lexer.lineno
		p.endpos = ( curpos - p.lexer.linepos)
		p.lexer.lexpos = curpos
		p.filename = p.lexer.filename
		p.value = s
		p.lexer.pop_state()
		return p

	def t_dquote_error(self,p):
		raise Exception('could make dquote (%s)'%(repr(p)))

	@lex.TOKEN(r'[a-zA-Z_0-9][a-zA-Z_0-9]*')
	def t_TEXT(self,p):
		# now to check whether it is the value of next is -
		selectval = None
		selectpos = None
		totaldata = None
		totalpos = None
		if p.lexer.lexpos < len(p.lexer.lexdata):
			curpos = p.lexer.lexpos
			curval = p.value
			while curpos < len(p.lexer.lexdata):
				curch = p.lexer.lexdata[curpos]
				#logging.info('curpos %d curch %s curval %s'%(curpos,curch,curval))
				breakone = True
				if curch == '-':
					leftdata = p.lexer.lexdata[(curpos+1):]
					findre = re.compile('^([a-zA-Z_0-9]+)')
					m = findre.findall(leftdata)
					if m is not None and len(m) > 0:
						breakone = False
						totaldata = curval + '-'+ m[0]
						totalpos = (curpos + 1 + len(m[0]))
						newtype = self.__class__.reserved.get(totaldata,'TEXT')
						if newtype != 'TEXT':
							# we find the last most match ones
							selectval = totaldata
							selectpos = (curpos + 1 + len(m[0]))
						curpos += (1 + len(m[0]))
						curval += '-' + m[0]
				if breakone:
					break
		if selectval is not None and selectpos is not None:
			p.value = selectval
			p.lexer.lexpos = selectpos
		elif totaldata is not None and totalpos is not None:
			p.value = totaldata
			p.lexer.lexpos = totalpos
		p.startline = p.lexer.lineno
		p.startpos = (p.lexer.lexpos - p.lexer.linepos - len(p.value))
		p.endpos = p.startpos + len(p.value)
		p.endline = p.startline
		p.filename = p.lexer.filename
		p.type = self.__class__.reserved.get(p.value,'TEXT')
		decre = re.compile('^[0-9]+$',re.I)
		hexre = re.compile('^[a-f0-9]+$',re.I)
		if p.type == 'TEXT':
			if decre.match(p.value):
				p.type = 'NUMBER'
			elif len(p.value) > 1:
				matchvalue = None
				if p.value.startswith('0x') or p.value.startswith('0X'):
					matchvalue = p.value[2:]
				if matchvalue is not None:
					if hexre.match(matchvalue):
						p.type = 'NUMBER'

		#logging.info('TEXT lineno [%s] lexpos [%s]'%(p.lineno,p.lexpos))
		return p

	def t_newline(self,p):
		r'\n'
		p.lexer.linepos = p.lexer.lexpos
		p.lexer.lineno += 1
		return None

	def t_carriage(self,p):
		r'\r'
		return None

	def t_error(self,p):
		self.column = (p.lexer.lexpos - p.lexer.linepos )
		self.lineno = p.lexer.lineno
		raise Exception('at [%s:%s] error [%s]'%(self.lineno,self.column,p.value))
		return

	def build(self,**kwargs):
		lexer = lex.lex(module=self,**kwargs)
		lexer.input = types.MethodType(tgtlex_input,lexer)
		lexer.orig_token = lexer.token
		lexer.token = types.MethodType(tgtlex_token,lexer)
		return lexer





def main():
	command='''
	{
		"verbose|v" : "+",
		"input|i" : null
	}
	'''
	parser = extargsparse.ExtArgsParse()
	parser.load_command_line_string(command)
	args = parser.parse_command_line()
	set_logging(args)
	s = read_file(args.input)
	tgtlex = TgtLex()
	lexer = tgtlex.build(lextab='tgtlex')
	fname = '<stdin>'
	if args.input is not None:
		fname = args.input
	lexer.input(s,fname)
	includetype = False
	while True:
		tok = lexer.token()
		if tok is None:
			break
		if not includetype and tok.type == 'INCLUDE':
			includetype = True
		else:
			if includetype and tok.type == 'TEXT':
				s = read_file(tok.value)
				lexer.input(s,tok.value)
			includetype = False
		sys.stdout.write('(%s,%r,%d,%d)[%s]\n' % (tok.type, tok.value, tok.startline, tok.startpos,tok.filename))
	return

if __name__ == '__main__':
	main()

